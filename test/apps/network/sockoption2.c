// SPDX-License-Identifier: MPL-2.0

/*
 * UNIX stream socket-related socket options.
 */

#include <stdio.h>
#include <stdlib.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <netinet/tcp.h>
#include <unistd.h>
#include <arpa/inet.h>
#include <sys/un.h>
#include <linux/filter.h>
#include <linux/if_ether.h>
#include <linux/if_packet.h>
#include <stdbool.h>
#include <sys/wait.h>
#include "test.h"

static int sk_unbound;
static int sk_listen;
static int sk_connected;
static int sk_accepted;
static int sk_tcp;
static struct sockaddr_un addr = { .sun_family = AF_UNIX,
				   .sun_path = "/tmp/sock_option_test" };

FN_SETUP(create_sockets)
{
	sk_unbound = CHECK(socket(PF_UNIX, SOCK_STREAM, 0));

	sk_listen = CHECK(socket(PF_UNIX, SOCK_STREAM, 0));
	CHECK(bind(sk_listen, (struct sockaddr *)&addr, sizeof(addr)));
	CHECK(listen(sk_listen, 3));

	sk_connected = CHECK(socket(PF_UNIX, SOCK_STREAM, 0));
	CHECK(connect(sk_connected, (struct sockaddr *)&addr, sizeof(addr)));

	sk_accepted = CHECK(accept(sk_listen, NULL, NULL));

	sk_tcp = CHECK(socket(AF_INET, SOCK_STREAM, 0));
}
END_SETUP()

FN_TEST(passcred)
{
	int val = 0;
	socklen_t len = sizeof(val);
	TEST_RES(getsockopt(sk_unbound, SOL_SOCKET, SO_PASSCRED, &val, &len),
		 _ret == 0 && val == 0);

	val = 100;
	TEST_SUCC(setsockopt(sk_listen, SOL_SOCKET, SO_PASSCRED, &val, len));
	TEST_RES(getsockopt(sk_listen, SOL_SOCKET, SO_PASSCRED, &val, &len),
		 _ret == 0 && val == 1);

	TEST_RES(getsockopt(sk_tcp, SOL_SOCKET, SO_PASSCRED, &val, &len),
		 _ret == 0 && val == 0);
	val = 1;
	TEST_SUCC(setsockopt(sk_listen, SOL_SOCKET, SO_PASSCRED, &val, len));
}
END_TEST()

bool is_filters_equal(struct sock_filter *f1, struct sock_filter *f2, int len)
{
	for (int i = 0; i < len; i++) {
		if (f1[i].code == f2[i].code && f1[i].jt == f2[i].jt &&
		    f1[i].jf == f2[i].jf && f1[i].k == f2[i].k) {
			continue;
		}

		return false;
	}
	return true;
}

FN_TEST(attach_filter)
{
	// Generated by `tcpdump -dd ip`
	struct sock_filter bpf_code[] = {
		{ 0x28, 0, 0, 0x0000000c },
		{ 0x15, 0, 1, 0x00000800 },
		{ 0x6, 0, 0, 0x00040000 },
		{ 0x6, 0, 0, 0x00000000 },
	};

	unsigned short filter_len =
		(unsigned short)(sizeof(bpf_code) / sizeof(struct sock_filter));

	struct sock_fprog bpf = {
		.len = filter_len,
		.filter = bpf_code,
	};

	TEST_SUCC(setsockopt(sk_unbound, SOL_SOCKET, SO_ATTACH_FILTER, &bpf,
			     sizeof(bpf)));
	TEST_SUCC(setsockopt(sk_tcp, SOL_SOCKET, SO_ATTACH_FILTER, &bpf,
			     sizeof(bpf)));

	socklen_t value = 0;
	TEST_RES(getsockopt(sk_unbound, SOL_SOCKET, SO_ATTACH_FILTER, NULL,
			    &value),
		 value == (socklen_t)filter_len);

	struct sock_filter *filter_buf =
		malloc(value * sizeof(struct sock_filter));
	TEST_RES(getsockopt(sk_unbound, SOL_SOCKET, SO_ATTACH_FILTER,
			    filter_buf, &value),
		 value == filter_len &&
			 is_filters_equal(filter_buf, bpf_code, value));
}
END_TEST()

FN_TEST(priority)
{
	int val = 0;
	socklen_t len = sizeof(val);
	TEST_RES(getsockopt(sk_unbound, SOL_SOCKET, SO_PRIORITY, &val, &len),
		 val == 0);

	val = -1;
	TEST_SUCC(setsockopt(sk_listen, SOL_SOCKET, SO_PRIORITY, &val, len));
	TEST_RES(getsockopt(sk_listen, SOL_SOCKET, SO_PRIORITY, &val, &len),
		 val == -1);

	val = 100;
	TEST_SUCC(setsockopt(sk_connected, SOL_SOCKET, SO_PRIORITY, &val, len));
	TEST_RES(getsockopt(sk_connected, SOL_SOCKET, SO_PRIORITY, &val, &len),
		 val == 100);
}
END_TEST()

FN_TEST(acceptconn)
{
	int val = 0;
	socklen_t len = sizeof(val);
	TEST_ERRNO(setsockopt(sk_unbound, SOL_SOCKET, SO_ACCEPTCONN, &val, len),
		   ENOPROTOOPT);

	TEST_RES(getsockopt(sk_unbound, SOL_SOCKET, SO_ACCEPTCONN, &val, &len),
		 val == 0 && len == 4);
	TEST_RES(getsockopt(sk_listen, SOL_SOCKET, SO_ACCEPTCONN, &val, &len),
		 val == 1 && len == 4);
	TEST_RES(getsockopt(sk_accepted, SOL_SOCKET, SO_ACCEPTCONN, &val, &len),
		 val == 0 && len == 4);
	TEST_RES(getsockopt(sk_connected, SOL_SOCKET, SO_ACCEPTCONN, &val,
			    &len),
		 val == 0 && len == 4);
	TEST_RES(getsockopt(sk_tcp, SOL_SOCKET, SO_ACCEPTCONN, &val, &len),
		 val == 0 && len == 4);
}
END_TEST()

FN_TEST(peer_cred)
{
	struct cred {
		pid_t pid;
		uid_t uid;
		gid_t gid;
	};

	struct cred ucred = {};
	socklen_t len = sizeof(ucred);
	TEST_ERRNO(setsockopt(sk_unbound, SOL_SOCKET, SO_PEERCRED, &ucred, len),
		   ENOPROTOOPT);
	TEST_RES(getsockopt(sk_tcp, SOL_SOCKET, SO_PEERCRED, &ucred, &len),
		 ucred.pid == 0 && ucred.uid == -1 && ucred.gid == -1);

	TEST_RES(getsockopt(sk_unbound, SOL_SOCKET, SO_PEERCRED, &ucred, &len),
		 ucred.pid == 0 && ucred.uid == -1 && ucred.gid == -1);

	pid_t pid = getpid();
	uid_t uid = geteuid();
	gid_t gid = getegid();

	TEST_RES(getsockopt(sk_listen, SOL_SOCKET, SO_PEERCRED, &ucred, &len),
		 ucred.pid == pid && ucred.uid == uid && ucred.gid == gid);
	TEST_RES(getsockopt(sk_accepted, SOL_SOCKET, SO_PEERCRED, &ucred, &len),
		 ucred.pid == pid && ucred.uid == uid && ucred.gid == gid);
	TEST_RES(getsockopt(sk_connected, SOL_SOCKET, SO_PEERCRED, &ucred,
			    &len),
		 ucred.pid == pid && ucred.uid == uid && ucred.gid == gid);

	// Test listen socket
	struct sockaddr_un addr_new = {
		.sun_family = AF_UNIX, .sun_path = "/tmp/sock_option_test_new"
	};
	int sk_listen_new = TEST_SUCC(socket(AF_UNIX, SOCK_STREAM, 0));
	TEST_SUCC(bind(sk_listen_new, (struct sockaddr *)&addr_new,
		       sizeof(addr_new)));
	TEST_SUCC(listen(sk_listen_new, 3));
	TEST_RES(getsockopt(sk_listen_new, SOL_SOCKET, SO_PEERCRED, &ucred,
			    &len),
		 ucred.pid == pid && ucred.uid == uid && ucred.gid == gid);
	int child_pid = fork();
	if (child_pid == 0) {
		// Child process
		int sk_connect_new = TEST_SUCC(socket(AF_UNIX, SOCK_STREAM, 0));
		TEST_SUCC(connect(sk_connect_new, (struct sockaddr *)&addr_new,
				  sizeof(addr_new)));
		TEST_RES(getsockopt(sk_connect_new, SOL_SOCKET, SO_PEERCRED,
				    &ucred, &len),
			 ucred.pid == pid && ucred.uid == uid &&
				 ucred.gid == gid);
		TEST_SUCC(close(sk_connect_new));
		exit(0);
	}

	sleep(1);
	int sk_accepted_new = TEST_SUCC(accept(sk_listen_new, NULL, NULL));
	TEST_RES(getsockopt(sk_accepted_new, SOL_SOCKET, SO_PEERCRED, &ucred,
			    &len),
		 ucred.pid == child_pid && ucred.uid == uid &&
			 ucred.gid == gid);
	TEST_RES(getsockopt(sk_listen_new, SOL_SOCKET, SO_PEERCRED, &ucred,
			    &len),
		 ucred.pid == pid && ucred.uid == uid && ucred.gid == gid);

	TEST_SUCC(wait4(child_pid, NULL, 0, NULL));
	TEST_SUCC(close(sk_listen_new));
	TEST_SUCC(close(sk_accepted_new));
	TEST_SUCC(unlink(addr_new.sun_path));
}
END_TEST()

bool is_groups_equal(gid_t *g1, gid_t *g2, int groups)
{
	for (int i = 0; i < groups; i++) {
		if (g1[i] != g2[i]) {
			return false;
		}
	}
	return true;
}

FN_TEST(peer_groups)
{
	int groups = TEST_SUCC(getgroups(0, NULL));
	gid_t *buffer = (gid_t *)malloc(groups * sizeof(gid_t));
	TEST_SUCC(getgroups(groups, buffer));

	TEST_ERRNO(setsockopt(sk_unbound, SOL_SOCKET, SO_PEERGROUPS, buffer,
			      groups),
		   EINVAL);

	socklen_t peer_groups = 1;
	gid_t tmp_buffer[1];
	TEST_ERRNO(getsockopt(sk_tcp, SOL_SOCKET, SO_PEERGROUPS, tmp_buffer,
			      &peer_groups),
		   ENODATA);
	TEST_ERRNO(getsockopt(sk_unbound, SOL_SOCKET, SO_PEERGROUPS, tmp_buffer,
			      &peer_groups),
		   ENODATA);
	TEST_ERRNO(getsockopt(sk_listen, SOL_SOCKET, SO_PEERGROUPS, tmp_buffer,
			      &peer_groups),
		   ERANGE);

	TEST_ERRNO(getsockopt(sk_connected, SOL_SOCKET, SO_PEERGROUPS, NULL,
			      &peer_groups),
		   EFAULT);
	gid_t *peer_buffer = (gid_t *)malloc(peer_groups);
	TEST_RES(getsockopt(sk_connected, SOL_SOCKET, SO_PEERGROUPS,
			    peer_buffer, &peer_groups),
		 peer_groups == groups * sizeof(gid_t) &&
			 is_groups_equal(peer_buffer, buffer, groups));

	int fildes[2];
	TEST_SUCC(socketpair(PF_UNIX, SOCK_STREAM, 0, fildes));
	TEST_RES(getsockopt(fildes[0], SOL_SOCKET, SO_PEERGROUPS, peer_buffer,
			    &peer_groups),
		 peer_groups == groups * sizeof(gid_t) &&
			 is_groups_equal(peer_buffer, buffer, groups));

	TEST_SUCC(close(fildes[0]));
	TEST_SUCC(close(fildes[1]));
}
END_TEST()

FN_SETUP(cleanup)
{
	CHECK(close(sk_unbound));
	CHECK(close(sk_listen));
	CHECK(close(sk_accepted));
	CHECK(close(sk_connected));
	CHECK(close(sk_tcp));
	CHECK(unlink(addr.sun_path));
}
END_SETUP()